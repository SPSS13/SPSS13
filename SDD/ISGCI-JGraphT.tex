% !TEX encoding = UTF-8 Unicode
% Vorlage zur Generierung von Uebungsloesungsblaettern.

\documentclass[10pt,a4paper]{article}
\usepackage[ngerman]{babel}
\usepackage{algorithm2e}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}  % Für z.B. Mengenzeichen
\usepackage{mathtools}
\usepackage[normalem]{ulem}
\usepackage{graphicx}
\usepackage{graphics} 
\usepackage[T1]{fontenc}
\usepackage{amssymb}
\usepackage{courier}
\usepackage{textcomp}
\usepackage{fancyhdr}
\usepackage{multirow}
\usepackage{color}
\usepackage{hyperref}

\newcommand{\G}[1]{\glqq\text{#1}\grqq} % damit man nicht immer `"'" tippen muss


\begin{document}


\thispagestyle{empty} %Seitennummerierung 1 ausblenden
\begin{center}
\includegraphics*[width=11cm]{Logo.png}
\end{center}


\vspace*{1cm} 
\begin{center}
{\huge Software Design Document}\\
{\large Version 1.1}\\
{\large 08. Juni 2013}\\
\end{center}

\begin{center}
{\large ISGCI $-$ Information System on Graph Classes and their Inclusions}\\
{\large Team $Graph$ $Maga$}
\end{center}


\newpage


\tableofcontents
\newpage
\section{Änderungsverlauf}
\hspace*{-1cm}
\begin{tabular}{|l|l|p{10.5cm}|}\hline
 \textbf{Version}&\textbf{Datum}&\textbf{Beschreibung der \"Anderung}\\\hline
 0.1&26.05.2013&Arbeitsversion\\\hline
 0.5& 07.06.2013 & Alle Sections zusammengeführt; 1. Einleitung verbessert, Ausdruck\\\hline
 0.51& 07.06.2013 & 2. Designziele verbessert, Ausdruck\\\hline
 0.52& 07.06.2013 & 3. ProblemsFunktionen des bestehenden Systems: Formulierungen\\\hline
 0.53& 07.06.2013 & Help, About, Zeichenfläche Kontextmenüs: Kommasetzung, Quoted Text (Gänsefüßchen), Format angepasst\\\hline
 0.54& 07.06.2013 & Information $-$ Verweis auf Browse Database $\rightarrow$ erledigt, \newline
 			      Ausdruck verbessert.\\\hline
 0.55& 07.06.2013 & 4. {Wichtige Klassen des bestehenden Systems}\newline
 				  JGraphT: Formulierungen angepasst\newline
 				  Layout: Formulierungen, Kommata, Quotes      \newline 
 				  GUI: Formulierungen, Kommata, Quotes\\\hline 
 0.56& 07.06.2013 & 5. Vorgeschlagene Software Architektur: \newline
 				  5.1 Übersicht: Kommata, Ausdruck, Formulierungen, Quotes\newline
 				  5.2 ISGCIGraph.java: Kommata, Ausdruck\newline
 				  5.3 ISGCI.gui: Kommata, Ausdruck\\\hline
 0.57& 07.06.2013 & 6. HW/SW Mapping \newline
 					Ausdruck, Kommata, Formulierungen\\\hline
 0.58& 07.06.2013 & 7. Testing: Kommata, Formulierungen verbessert.\\\hline
 0.6& 07.06.2013 & Gesamtes SDD: Rechtschreibung verbessert.\\\hline
 1.0& 07.06.2013 & SDD Version 1.0 \\\hline
 1.1& 08.06.2013 & Änderungen Punkt 5: Vorgeschlagene Software Architektur. \newline Umsetzung nach altem Design nicht möglich. \newline Vgl. 5.3 - ISGCI.GUI Grundlegende Änderungen\\\hline
 %1.0&28.05.2013&Basissversion\\\hline
\end{tabular}\\
\section{Einleitung}
Das gelieferte Produkt ist eine Aktualisierung des bestehenden ISGCI. Das bestehende ISGCI wird mit Funktionalitäten der Graphenzeichenbibliothek JGraphX erweitert. Außerdem werden der neuen Version verschiedene neue Features hinzugefügt, die zur Verbesserung der Benutzerfreundlichkeit beitragen sollen. Zweck des Updates ist es, nicht nur die Verfügbarkeit des Tools in Zukunft zu gewährleisten und neue Funktionen zu implementieren, sondern auch die Instandhaltungskosten zu senken und das Tool für interessierte Entwickler und Nutzer ansprechender zu gestalten.
\subsection{Designziele}
%copy pasta aus dem SRS
\begin{itemize}	
		\item \textbf{Benutzerfreundlichkeit}\\
		Das bestehende System wird vor allem deshalb erweitert, um die Benutzerfreundlichkeit zu steigern. Zwar besteht ein Teil der Zielgruppe für die Software aus technisch interessierten und fähigen Personen, dennoch gibt es auch eine breite Nachfrage im Bereich der Computer-Laien, weshalb die Software auch für diese leicht durchschaubar und selbsterklärend sein soll. Intuitiv angeordnete Reiter in der Menüleiste, sowie ein interaktives Kontextmenü sollen dazu beitragen, dass benötigte Funktionen von Benutzern leicht gefunden werden können. Zudem sorgen Funktionen wie \G{Grab\&Pull} oder Zoom für einen interaktiven Umgang mit dem System. Um die Übersichtlichkeit über komplexere Graphen zu gewährleisten, gibt es zwei Varianten des \G{Expanding/Collapsing}, mit denen man einen komplizierten Graphen in einen überschaubaren Teilgraphen verkleinern kann.
		\item \textbf{Integrität}\\
		Alle Datensätze werden zentral auf einem Server gehalten. Die Software bietet ausschließlich lesende Funktionen an. Somit ist die Datenbank durch negative Manipulationen geschützt.
		\item \textbf{Flexibilität}\\
		Nutzer können ihren Wunschgraphen zeichnen lassen, diesen auf verschiedene Arten manipulieren (z.B.: neu anordnen, reduzieren, Knoten-Hierarchien anzeigen lassen) und den entstandenen Graphen exportieren. Dazu können zu jedem Graph-Knoten (Graphklasse) Informationen aus der Online-Datenbank eingesehen werden.  
		\item \textbf{Portabilität}\\
		ISGCI ist eine Java Anwendung. Das bedeutet, dass sie plattformunabhängig ausgeführt werden kann, solange eine Java-Laufzeit-Umgebung installiert ist (als Standard vorausgesetzt).\\
		Die Online-Datenbank ist unabhängig von unserem System. 
		\item \textbf{Wartbarkeit}\\
		Dadurch, dass die Datenbank des Programmes online, zentral gelagert wird, lassen sich Datensätze leicht und ohne Updates im Programm manipulieren oder hinzufügen.
		\end{itemize}


\subsection{Referenzen}
%http://www.graphclasses.org/help.html
\begin{table}[h]
          	\caption{Verweise}
          	\label{fig:figurename}
          	\begin{center}
          		\begin{tabular}{|l|p{10cm}|c|}
          		\hline
          
          		\hline
          		\textbf{Name} & \textbf{Quelle} & \textbf{Datum} \\
          		\hline
          			 ISGCI & \href{http://www.graphclasses.org/help.html}{Graphclasses.org - ISGCI Homepage} & 04.06.2013\\ \hline
          			 JGraphT & \href{http://jgrapht.org/}{JGraphT Website} & 04.06.2013 \\ \hline
          			 JGraphX & \href{http://www.jgraph.com/}{JGraph Website} & 04.06.2013 \\  \hline
          			  & \href{http://jgraph.github.io/mxgraph/java/docs/index.html}{JGraph Dokumentation} & 04.06.2013 \\  \hline
          			  & \href{https://github.com/jgraph/jgraphx}{JGraphX Library Quellcode} & 04.06.2013\\  \hline
					Swing & \href{http://docs.oracle.com/javase/1.4.2/docs/api/javax/swing/package-summary.html}{Swing Dokumentation} & 04.06.2013 \\  \hline
					Java & \href{http://docs.oracle.com/javase/6/docs/api/}{Java 6 Dokumentation SE} & 04.06.2013 \\  \hline
          		\end{tabular}
          	\end{center}
          \end{table}
\subsection{Übersicht}
\begin{itemize}
\item Funktionen des bestehenden Systems\\
\textit{Beschreibung des bestehenden Systems mit allen Funktionen. Systematische Aufgliederung aller Reiter und Interaktionsmöglichkeiten.}
\item Wichtige Klassen des bestehenden Systems\\
\textit{Kurze Erläuterung der Aufgaben benötigter Packages und deren Klassen. Heraushebung der Zusammenhänge innerhalb der Packages.}
\item Vorgeschlagene Software Architektur\\
\textit{Definition des Aufbaus und der neuen, hinzuzufügenden Funktionen im erweiterten System.}
\item Hardware/Software Mapping\\
\textit{Beschreibung des notwendigen Software-Umfeldes der Software und Hardwarevoraussetzungen.}
\item Integrationstests\\
\textit{Aufstellung aller Integrationstests.}
\end{itemize}  
\newpage
\section{Funktionen des bestehenden Systems}
\label{sec:bestSys}
Beschreibung der aus dem GUI ableitbaren Funktionen
\subsection{File}
Der Menüreiter "`File"'\ enthält drei grundlegende Funktionen zur Bedienung des Programms. Es lassen sich weitere Fenster der ISGCI Applikation öffnen, falls man beispielsweise mehrere Graphen gleichzeitig zeichnen lassen und betrachten möchte.\\
Zudem lässt sich das Dialogfenster "`Export drawing..."'\ öffnen um einen gezeichneten Graphen in eine Datei zu exportieren. Dabei stehen drei Dateiformate zu Verfügung: Postscript, Structured Vector Graphics und GraphML. Zuletzt lässt sich mit "`Exit"'\ das aktuelle Fenster schließen.\\

\subsection{View}
\emph{View stellt beim Klicken auf den Menüreiter "`View"'\ in der Navigationsleiste verschiedene Funktionen zur Optimierung der Ansicht zur Verfügung. Darunter fällt das Suchen nach einer Graphklasse, die Einstellung der Namensanzeige und das Markieren von "`unproper"' (müsste eigentlich improper heißen) inclusions.}\\

\paragraph{Search in drawing...}\ \\
Beim Auswählen des Punktes "`search in drawing"' durch einen Mausklick, öffnet sich das Fenster "`Search for a graphclass"'. Aus einer Liste kann in diesem Feld eine Graphklasse aus allen Graphklassen ausgewählt werden und durch das Drücken von \G{Search} gesucht werden. Dabei werden stets nur die Graphklassen angezeigt, die im Drawing auffindbar sind. Durch "`cancel"' kann der Suchvorgang abgebrochen werden. Sucht man mittels Drücken auf "`search"' nach einer aus der Liste gewählten Klasse, dann wird der Canvas so verschoben, dass die Graphklasse sichtbar ist.


\paragraph{Naming preference...}\ \\
Beim Auswählen des Punktes "`Naming preference.."', durch einen Mausklick, öffnet sich das Fenster "`Naming preference"'. Dieses stellt drei Möglichkeiten durch Radio-Buttons zur Auswahl. Dabei kann immer nur ein Radio-Button aktiv sein. (Eigenschaft der Radio-Buttons) \\
\begin{itemize}
	\item[\bf{Basic}] e.g. threshold
	\item[\bf{Forbidden subgraphs}] e.g. ($P_4,2K_2,C_4$)-free
	\item[\bf{Derived}] e.g. cograph $\cap$ split\\
\end{itemize}
Das Auswählen einer dieser drei Optionen und das Bestätigen durch "`OK"', hat eine Umbenennung aller Knoten im Drawing entsprechend angegebenen Konvention zur Folge.

\paragraph{Mark unproper(improper) inclusions}\ \\
Beim Auswählen des Punktes "`Mark unproper inclusions"', durch einen Mausklick, wird dieser Menüpunkt mittels eines ein-/ausblendbaren Häkchen als aktiv / inaktiv gekennzeichnet. Wird dieser Menüpunkt als aktiv gekennzeichnet, so werden alle "`unproper inclusions"' durch verblasste (geringere Opacity, Grauwert anstelle von Schwarz) Pfeile an einer Kante dargestellt. Wobei der Pfeil auf die Graphklasse mit "`unproper inclusions"' zeigt. Nach Deaktivieren dieser Funktion verschwindet dieser graue Pfeil.


\subsection{Graph classes}
\emph{Der Reiter "`Graph classes"' in der Menüleiste stellt verschiedene Funktionen zum Finden von Klassen anhand derer Eigenschaften und Browsen durch die Graph-Klassen-Datenbank zur Verfügung, die im Folgenden näher erläutert werden.}
Bevor folgende Schritte getan werden können, muss der bereits genannte Reiter per Mausklick (egal ob rechts oder links) ausgewählt(geöffnet) werden.\\
Ein wichtiger Punkt ist, dass egal welche Fenster geöffnet sind, der Benutzer nicht im Hauptfenster blockiert wird, auch wenn er über dieses bereits ein anderes geöffnet hat. Dies ist für den Benutzer sehr hilfreich, da er sich keine Informationen zur aktuellen Einstellung (z.B. im "`Browse Database"') merken muss und gleichzeitig nach etwas anderem schauen kann.
\paragraph{Browse Database}\ \\
Durch Klicken auf die Auswahlmöglichkeit "`Browse Database"' öffnet sich das Fenster "`Graph Class Information"'. Nun hat man die Möglichkeit Graphklassen anzuwählen, um über diese Informationen zur Komplexität der Probleme zu Graphklassen zu erhalten (Eine Tabelle mit 2 Spalten: Problem und Complexity; nicht alphabetisch geordnet). Außerdem steht ein Filter zu Verfügung, mit dem man durch Eingeben des Namens oder nur ein Teil davon, dabei ist egal, an welcher Stelle er im Namen der Graphklasse steht, die Informationen zu Klassen, welche die Eingabe beinhalten, angezeigt bekommt.\\
Zu diesen Informationen gehören nicht nur die Komplexität von Problemen. Unter der bereits genannten Tabelle sind 3 weitere, nebeneinanderstehende Listen mit gleicher Breite angeordnet. Diese Listen beinhalten (von links nach rechts erklärt) alle Superklassen, Äquivalenzklassen und Subklassen (zur in der ersten Liste ausgewählten Graphklasse). Durch Verändern der Breite und Höhe des Fensters verändert sich dynamisch die Größe der Listen. Während sich bei der Tabelle(Probleme) nur die Breite verändert, da diese eine feste Anzahl an Zeilen hat, verändert sich die Höhe der Listen ebenfalls relativ zur Fenstergröße. Die Breite der "`Graph Class"'-Liste erstreckt sich über die Breite des gesamten Fensters(entsprechend der 3 Listen im unteren Teil zusammen). In jeder Liste sind die Klassen alphabetisch angeordnet (Groß- vor Kleinbuchstaben; Sonderzeichen werden ignoriert), sodass man seine gewünschte Graphklasse auch darüber filtern kann. Wichtig ist, dass in jeder der 4 Listen, in denen die aktuellen Graphklassen bezüglich ihrer Eigenschaft zur Auswahl, angewählt werden können, sodass man sich durch die Zusammenhänge der Klassen "`klicken"' kann. Zu beachten ist, dass durch einfaches Anwählen die Klassen in den unteren 3 Listen nur markiert werden und erst deren Informationen nach einem Doppelklick(Linksklick) angezeigt werden, während man durch einfaches Anwählen einer Klasse in der oberen Liste, sofort dessen Informationen zu entsprechenden Problemen erhält (ohne Doppelklick).\\
Ganz unten im Fenster werden zentriert verschiedene Buttons angezeigt:
\begin{itemize}
\item[Class details:] Ist der 1. Button (von links). Durch einfachen Linksklick wird die entsprechende Detail-Seite im Standard-Browser geöffnet und zeigt ausführlichere Informationen zur aktuell ausgewählten Graph Klasse der oberen Liste im Fenster. Dazu gehören "`References, Related classes, Inclusions, Problems(alphabetisch geordnet)"'
\item[Inclusion info:] Ein Linksklick auf diesen Button (2.) öffnet ein weiteres (kleines) Fenster("`Relation"'), welches Informationen zu Inklusionen zu anderen Graphklassen anzeigt. Im unteren Teil dieses Fensters befinden sich 3 Buttons:
\begin{itemize}
\item View references: öffnet eine Seite im Standard-Browser mit Referenzen auf Literatur bezüglich der angegebenen Inklusion(en) ("`Relation"').
\item Draw: Zeichnet im Hauptfenster("`ISGCI"') einen Graphen inklusiv der Inklusionen zu den aktuell im Relation-Fenster angezeigten Inklusion.
\item OK: Einfacher Button, dessen Betätigung zur Schließung des Relation-Fensters führt.
\end{itemize}
\item[Draw:] Durch Betätigung dieses Buttons(3.) wird ein weiteres Fenster ("`Select Graph Classes"') geöffnet, welches wie im vorigen einen analogen Filter zur Limitierung der angezeigten Klassen in der darunter befindlichen Liste hervorruft. In diesem Fenster steht im Gegensatz zum vorigen Fenster ("`Graph Class Information"') nur eine Liste, welche als Standard-Auswahl immer die Graphklasse des vorigen Fensters ausgewählt hat, damit der Benutzer nicht erneut die Klasse suchen muss, welche er im Hauptfentser ("`ISGCI"') anzeigen möchte. Der Benutzer hat zusätzlich über zwei Checkboxen, die sich unter der Liste befinden, die Möglichkeit, zu der ausgewählten Graphklasse auch deren Super- bzw. Subklasse durch Aktivieren der Checkboxen für die jeweiligen Klassen mit in dem zu zeichnenden Graphen anzuzeigen. \\ Im unteren Teil dieses Fenster befinden sich der Button "`New drawing"' über den der Benutzer seine Auswahl bestätigen kann, sich das Fenster schließt und im Hauptfenster das Ergebnis (den gezeichneten Graphen mit/ohne seine Super-/Subklassen) betrachten kann. Rechts neben dem eben genannten Button befindet sich ein "`Cancel"'-Button, welcher das Fenster schließt, ohne dass sonst etwas im Programm geschieht und der Benutzer wird zu dem Fenster zurückgeführt, von dem aus er dieses geöffnet hat ("`Graph Class Information"').
\item[Close:] Wenn der User diesen Button (ganz rechts; 4.) klickt (Linksklick), wird das Fenster "`Graph Class Information"' geschlossen und der Benutzer gelangt zum Hauptfenster "`ISGCI"' zurück, in dem die letzte ausgewählte Zeichnung noch angezeigt wird.
\end{itemize}
\paragraph{Find Relation...} \ \\
Über diesen Auswahlpunkt öffnet sich durch Klicken (rechts/links) das Fenster "`Find Relation"'. In diesem hat der Benutzer die Möglichkeit über 2 untereinander dargestellte Listen, welche alle Graphklassen beinhalten, oder über einen Filter (je Liste), zwei Graphklassen anzuwählen und sich über einen darunter befindlichen Button "`Find Relation"' deren Verbindung anzusehen. Die Filter Funktion ist dabei analog zu der Filter-Funktion in dem Auswahlpunkt "`Browse Database"' umgesetzt. Nach Betätigung des eben genannten "`Find relation"' Buttons öffnet sich ein weiteres Fenster, welches nun Informationen zur Relation der angewählten Klassen anzeigt (wird im links oben auf dem Bildschirm geöffnet). Die angezeigten Verbindungen der beiden Klassen werden begründet, in welchem Zusammenhang sie stehen und nicht nur, dass sie es tun ("`by definition, forbidden subgraphs ..."'). Dabei zu beachten ist, dass sich die Größe des Fenster an der Menge des zu anzeigenden Textes orientiert, sodass das Fenster möglich wenig Platz auf dem Bildschirm einnimmt. Zusätzlich zu diesen Relation-Informationen kann man über den Button "`View references"' (links unten im Fenster) Referenzen zu Literatur über die graphclasses.org - Homepage anzeigen lassen. Über einen weiteren Button (rechts von "`View references"') kann der Benutzer diese Relation im Hauptfenster zeichnen lassen (mit dazwischenliegenden Klassen), analog zur "`Draw"'-Funktion des bereits erklärten Auswahlpunktes. Ein dritter Button "`OK"' (rechts von "`Draw"') führt (ebenfalls analog) zur Schließung des "`Relation"' Fensters und der Benutzer kommt zum "`Parent-Fenster"' zurück.\\
Rechts neben dem Button "`Find relation"' befindet sich der Button "`Close"' (beide ganz unten im Fenster horizontal zentriert), der ebenfalls analog zur schon bereits genannten Funktion dieses Fenster schließt und zum Hauptfenster zurückführt.

\paragraph{Draw...}\ \\
Dieser letzte Auswahlpunkt im Reiter "`Graph classes"' der Menüleiste führt zu dem exakt identischen Fenster, wie beim Klicken des "`Draw"' Buttons über den Auswahlpunkt "`Browse Database"' (nur eben nicht über diesen Umweg), falls der Benutzer schon weiß, welche Klassen er gezeichnet bekommen möchte. Dieses Fenster hat den selben Namen "`Select Graph Classes"' und beinhaltet ebenso einen Filter und eine Liste zu allen Graph-Klassen, in dem die gewünschte Klassen angewählt und mit/ohne deren Super-/Subklassen gezeichnet werden kann. Mit der Bestätigung über den Button "`New drawing"' schließt sich das Fenster und die Auswahl wird in dem Hauptfenster graphisch dargestellt.

\subsection{Problems}
\emph{Der Menüpunkt Problems stellt Funktionen zur Verfügung mit denen man untersuchen kann ob und in welcher Laufzeit ein Graphproblem auf den verschiedenen Graphklassen gelöst ist} \\
\href{http://www.graphclasses.org/help.html\#problems}{http://www.graphclasses.org/help.html\#problems}
\paragraph{Boundary/Open Classes} \ \\
Wird benutzt um herauszufinden, welche Probleme in P oder in NP liegen und wo die Grenzen sind. Man kann mit dieser Funktion neue Graphen zeichnen.\\
Implementierte Probleme:\\
\begin{minipage}{\linewidth}
{\small \begin{itemize}
\item Recognition
\item Treewidth
\item Cliquewidth
\item Cliquewidth expression
\item Weighted independend set
\item Independend set
\item Clique
\item Domination
\item Colourability
\item Clique cover
\item 3-Colourability
\item Cutwidth
\item Hamilton circle
\item Hamilton path
\item Weighted feedback vertex set
\item Feedback vertex set
\end{itemize}}
\end{minipage}
\paragraph{Color for Problem} \ \\
Zeigt an, in welcher Laufzeit ein Algo in der jeweiligen Klasse zu lösen ist.  Bei einigen Algo`s gibt es spezielle Regeln, wie die Einfärbung funktioniert. Beschreibung siehe \href{http://www.graphclasses.org/help.html\#problemdefs}{http://www.graphclasses.org/help.html\#problemdefs} \\
Implementierte Probleme:
Siehe oben.
\subsection{Help}
\paragraph{Small Graphs}\ \\
Beim Auswählen des Punktes \G{Small Graph} wird die URL\\ \href{http://www.graphclasses.org/smallgraphs.html}{http://www.graphclasses.org/smallgraphs.html} \\
aufgerufen.\\
\paragraph{Help}\ \\
Beim Auswählen des Punktes \G{Help} wird die URL\\ \href{www.graphclasses.org/help.html}{www.graphclasses.org/help.html}\\ aufgerufen.
\paragraph{About}\ \\
Beim Auswählen des Punktes \G{About} öffnet sich ein Fenster mit dem Namen \G{About ISGCI}. Darin steht die Bedeutung von ISGCI (Information System on Graph Classes and their Inclusions). Es ist außerdem die Versionsnummer aufgeführt, dass es von H.N. de Ridder et al. geschrieben wurde und dass es das JGraph Library nutzt. Es wird weiterhin aufgeführt, wie viele Klassen und Inklusionen in der Datenbank sind und wann diese erstellt wurde. Es ist ein Link zur Website angegeben. Zum Schließen des Fensters, kann man auf \G{OK} klicken.
\subsection{Zeichenfläche/Kontextmenüs}
\begin{itemize}
\item veränderbare Fenstergröße 
\item bei leerem Fenster: keine Interaktion möglich (über die Navigationsleiste natürlich schon) - Rechts-/Links-Klick ohne Auswirkungen.
\item Fenstergröße und Position(absolut) verändert sich durch neues Zeichnen nicht automatisch. (Ausnahme: falls der alte Sichtbereich nicht mehr im Sichtbereich der neuen Zeichnung liegt, wird die nächstmögliche Ansicht gewählt.)
\item Klicks in den leeren Raum haben keine Auswirkungen.
\item Kontextmenü (Rechtsklick auf Kanten/Knoten):
\begin{itemize}
\item Knoten: 
\begin{itemize}
\item Information:
\begin{itemize}
\item Es öffnet sich ein neues Fenster (\G{Graph Class Information}). Aktuell ausgewählt ist die Graphen-Klasse, über die man Information angeklickt hat. Es ist möglich andere Klassen auszuwählen.
\item Filter: Über ein Filter-Eingabefeld kann man bestimmte Graph-Klassen suchen und auswählen.
\item Von der ausgewählten Klasse werden folgende Dinge gelistet: Probleme (\G{Problem}), die bei dieser Graph-Klasse vorkommen, und jeweils deren zugehörige Komplexität (\G{Complexity}); Superklassen (\G{Superclasses}); Äquivalente Klassen ("`Equivalent Classes"'); Unterklassen (\G{Subclasses}).
\item Über Doppelklick auf eine Klasse in einer der Listen Superklassen, Äquivalente Klassen oder Unterklassen wird die aktuell ausgewählte Klasse neu gesetzt und die angezeigten Informationen entsprechend angepasst.
\item \G{Class-details}-Button:\\ Standard-Browser wird geöffnet. \\
{\small Weiterleitung zur http://www.graphclasses.org/ - Detailseite zur aktuell ausgewählten Graph-Klasse.}
\item \G{Inclusion-info}-Button: \\
Funktioniert nur, falls eine Klasse in Superklassen, Äquivalenten Klassen oder Unterklassen markiert (ausgewählt) ist.\\
Es öffnet sich ein Pop-Up, in dem die Relation zwischen der aktuell ausgewählten Graph-Klasse und der unten markierten Klasse dargestellt wird (Zusammenhang - Mengenbeziehungen).\\
Es sind drei Buttons zu finden: \G{View references} - Öffnet im Standardbrowser die Referenz-Seite von GraphClasses.org; \G{Draw} $-$ Zeichnet alle in der Relation beteiligten Graph-Klassen und deren Zusammenhang; \\\G{OK} $-$ Pop-Up schließen.
Während der Pop-Up offen ist, wird die restliche Anwendung blockiert.
\item \G{Draw}-Button:\\ Ruft Draw-Pop-Up auf. Gleiches Pop-Up, wie unter Reiter "`Graph classes"'$-$"`Draw"'.
\item \G{Close}-Button: \\Schließt das "`Graph Class Information"'-Fenster.
\end{itemize}
\item \G{Change Name}:\\
Im Kontextmenü erscheint eine weitere Ebene, in der alle äquivalenten Klassen zu der jeweiligen Klasse aufgelistet werden. Durch Anklicken einer dieser Klassen wird der Name des Knoten entsprechend geändert.
\end{itemize}
\item Kanten:
\begin{itemize}
\item Information:\\
Klickt man mit Rechtsklick auf eine Kante und dann auf "`Information"', erscheint ein Pop-Up, das die Relation zwischen den beiden verbundenen Knoten zeigt (gleiches Pop-Up bei Knoten/"`Information"'/"`Inclusion info"' - vgl. oben)
\end{itemize}
\end{itemize}
\item Knoten-Position: Knoten können verschoben werden (halten Linksklick, ziehen). Da die Knoten Nach einem Algorithmus gezeichnet wurden, der hierarchisch alle Ebenen durchgeht, bleiben Kanten, die von dem verschobenen Knoten ausgehen/ankommen in der Ebene darunter/darüber an einem bestimmten Punkt oder Knoten fixiert (feste virtuelle Knoten können nicht verschoben werden).
\item Pfeile: "`normale"', schwarze Pfeile deuten eine Inklusion in Richtung der Pfeilspitze an. Befindet sich am anderen Ende des Pfeiles noch entgegengesetzt eine graue Pfeilspitze, dann bedeutet es, dass die eine Graph-Klasse nicht notwendigerweise eine Teilmenge der anderen ist - es könnte auch Gleichheit herrschen (Unbekannt/\G{Datenbank-Lücke}). 
\end{itemize}
\subsection{Information Fenster}
Das \G{Information} Fenster enthält eine Liste aller enthaltenen Graph-Klassen, aus welcher eine Klasse mithilfe der Maus ausgewählt werden kann. Entsprechend der Auswahl wird unterhalb eine Tabelle angezeigt, welche alle Probleme enthält und die zur ausgewählten Klasse zugehörige Komplexität angibt. Im Unteren Bereich werden zusätzlich Listen für Superklassen, Äquivalente Klassen und Subklassen angezeigt, innerhalb dieser drei Listen kann eine weitere Klasse ausgewählt werden. Es ist ein Textfeld vorhanden, welches bei bestehender Internetverbindung eine WebSearch (Packagebeschreibung GUI) ausführt, um die Liste der Graph-Klassen zu filtern. Neben einem Close Button um das Information Fenster zu schließen existieren außerdem ein \G{Draw} Button der zum Zeichnen des gewählten Graphen auf dem GraphCanvas dient, ein "`Inclusion"' Info Button der, falls eine Graph-Klasse und innerhalb der unteren Listen eine weitere Klasse ausgewählt wurde, ein Fenster mit Informationen zur Inklusion dieser beiden Klassen öffnet, sowie ein "`Class details"' Button, welcher einen Hyperlink zum entsprechenden Datenbankeintrag auf www.graphclasses.org/classes/... enthält.\\
\G{Inclusion info} Fenster: Das Fenster enthält Informationen zur gewählten Inklusion in textueller Form, sowie die Buttons \G{OK}, zum Schließen des Fensters, \G{Draw}, zum Zeichnen der Inklusion auf dem GraphCanvas und \G{View references}, welche einen Hyperlink zum entsprechenden Datenbankeintrag auf \\http://www.graphclasses.org/classes/... enthält.

\section{Wichtige Klassen des bestehenden Systems}
\subsection{ISGCI-Package JGraphT}

\paragraph{Allgemein:}\ \\
JGraphT wird benötigt, um die Graph-Struktur zu verwalten und Funktionen darauf auszuführen. Der Schwerpunkt liegt auf Funktionen zur logischen Reduzierung des Graphen und Filterung bestimmter Zusammenhänge (Nachbarn bestimmen etc.). Daneben werden noch nützliche Algorithmen zur Verarbeitung von Graphen bereitgestellt (z.B. Walkers).\\


\paragraph{Annotation.java}\ \\
Zuständig für Informationen(Kommentare/Anmerkungen), die an Knoten oder Kanten angehängt werden (Benutzt z.B. von Walkern zur Markierung bereits besuchter Knoten).\\
Verschiedene Funktionen ermöglichen in einem Annotation-Objekt bestimmten Knoten/Kanten Informationen (Data) zuzuordnen und auszulesen.\\

\paragraph{AsWeightedDirectedGraph.java}\ \\
\emph{Erweitert AsWeightedGraph und implementiert DirectedGraph}\\
Notwendig zur gewichteten und gerichteten Darstellung des Graphen.\\
Mithilfe dieser Klasse können Algorithmen, die für ungewichtete Graphen ausgelegt sind, auch auf gewichtete angewendet werden (Mapping von Kanten und Gewichten).\\

\paragraph{BFSWalker.java}\ \\
\emph{Erweiterung von GraphWalker}\\
Beinhaltet BFS Algorithmus(Breitensuche). Durchläuft einen Graphen, ausgehend von einem gegebenen Startknoten (benutzt nur Kanten).\\
Umsetzung: Alle Knoten kommen in eine Warteschlange, werden nach und nach (via. BFS) besucht und aus der Queue gelöscht.\\

\paragraph{DFSWalker.java}\ \\
\emph{Erweiterung von GraphWalker}\\
Beinhaltet DFS-Algorithmus(Tiefensuche). Durchläuft alle Knoten eines Graphen, ausgehend von einem gegebenen Startknoten.\\
Umsetzung: Über ein Annotation-Objekt können besuchte Knoten markiert werden. Durchlauf mittels DFS-Algorithmus.\\

\paragraph{GraphWalker.java}\ \\
\emph{Abstrakte Klasse}\\
GraphWalkers werden benötigt, um einen Graphen zu durchlaufen $-$ vgl. BFSWalker/DFSWalker. \\

\paragraph{CacheGraph.java}\ \\
\emph{Erweiterung von ListenableDirectedGraph}\\
Ermöglicht die Erstellung eines gerichteten Graphen mit Caching von Kanten und Knoten.\\
Umsetzung: HashMaps jeweils für Knoten und Kanten.\\
Überschreibt verschiedene Methoden/stellt zur Verfügung: Suchen von Knoten/Kanten, Feststellung ob Knoten/Kanten vorhanden sind und Konsistenz-Checks.\\

\paragraph{ClosingDFS.java}\ \\
\emph{Erweiterung von DFSWalker}\\
Definition von Closed Graph: "`In a directed graph G = (V, A), a set S of vertices is said to be closed if every successor of every vertex in S is also in S. Equivalently, S is closed if it has no outgoing edge"'.\\
Beinhaltet DFS Algorithmus zur rekursiven Bestimmung der transitiven Abgeschlossenheit eines Graphen (Menge an Knoten/Kanten, so dass der Graph abgeschlossen ist).\\

\paragraph{Deducer.java}\ \\
Stellt einen Algorithmus zur Entfernung aller trivialen Inklusionen in einem Graphen zur Verfügung.\\
Beinhaltet verschiedene Funktionen: Statistik $-$ Auskunft über Relationen, Inklusionen und deren Beschaffenheiten; Suche und Entfernung trivialer Inklusionen (Umformungen, teilweise Umstrukturierung des Graphen)\\

\paragraph{GAlg.java}\ \\
Beinhaltet verschiedene Algorithmen und andere Funktionen für Graphen.\\
Funktionen: Aufteilen des Graphen in Zusammenhangskomponenten; Selektion aller Nachbarn eines Knoten; Bestimmung eines Pfades zwischen zwei Knoten; Angabe der topologischen Ordnung eines Graphen(falls möglich); Transitive Reduzierung des Graphen.\\

\paragraph{Inclusion.java}\ \\
\emph{extends org.jgrapht.graph.DefaultEdge
        implements Relation}\\
Diese Klasse hält die Informationen einer Kante, nämlich Super- und Subklasse und ob es sich um eine unklare Inklusion handelt oder nicht.\\
\paragraph{ISGCIVertexFactory.java}\ \\
\emph{ implements VertexFactory<Set<GraphClass> >}\\
Klasse, um virtuelle Knoten zu erstellen.\\
\paragraph{RevBFSWalker.java}\ \\
\emph{extends BFSWalker<V,E>}\\
Durchläuft einen Graphen mittels gerichteter Breitensuche.\
\paragraph{TreeBFSWalker.java}\ \\
\emph{ extends UBFSWalker<V,E>}\\
Durchläuft den Spannbaum eines Graphen mittels ungerichteter Breitensuche. Anmerkung: Markiert nicht selbstständig den Spannbaum.\\
\paragraph{TreeDFSWalker.java}\ \\
\emph{extends UDFSWalker<V,E>}\\
Durchläuft die Knoten des Spannbaums eines Graphen mittels ungerichteter Tiefensuche.\\
\paragraph{UBFSWalker.java}\ \\
\emph{ extends BFSWalker<V,E>}\\
Durchläuft den Graphen mittels ungerichteter Breitensuche.\\
\paragraph{UDFSWalker.java}\ \\
\emph{extends DFSWalker<V,E>}\\
Ungerichtete Tiefensuche wird verwendet, um den Graphen zu durchlaufen.\\
\paragraph{WalkerInfo.java}\ \\
\emph{}\\
Diese Klasse wird benutzt um Knoten Informationen zu geben, während der Graph mittels Tiefen- oder Breitensuche durchlaufen wird.

\subsection{ISGCI-Package Layout}

Alle Klassen, die in dem \texttt{./layout}-Package stehen, sind für das Layout des letztendlich zu zeichnenden Graphen zuständig. Dabei stehen diese stark mit den Klassen aus dem \texttt{./grapht}-Package in Zusammenhang. Die Klassen und deren Methoden werden über die Klassen des \texttt{./gui}-Packages aufgerufen.

Im Folgenden werden alle Klassen aus dem \texttt{./layout}-Package grob beschrieben und deren Funktionweise und Zuständigkeit näher erläutert. Konkrete Details, wie Methodendeklarationen, Methodenaufrufe und Variablen werden spärlich erläutert. Dies sollte der Verständlichkeit nicht im Wege stehen, ferner sogar dienen.

\paragraph{GraphDrawInfo.java}\ \\
\emph{Erweiterung von WalkerInfo.java}\\
{\footnotesize Diese Klasse erweitert die Klasse \texttt{WalkerInfo.java} aus dem Package \texttt{./grapht}, welche dafür zuständig ist, ob Kanten zu einem zu berechnenden/anzuzeigenden Graphen gehört oder nicht. Bei Knoten wird auf Adjazenz geprüft (näheres in der Beschreibung bei \texttt{grapht}), ob der Knoten zum dem zu zeichnenden Graphen gehört. Sie fügt weitere Variablen, die Werte für Knoten und Kanten beinhalten, welche zur Graphzeichnung benötigt werden, ein. Dazu gehören auch virtuelle Knoten, die keinen Inhalt haben und nur zur Kantenzeichnung benötigt werden. Außerdem werden Variablen zur Ranking-Berechnung deklariert, um die spätere richtige Position in der Zeichnung zu bestimmen. Alle benötigten Variablen werden im Konstruktor mit Default-Werten instantiiert und überschrieben, sobald diese benötigt werden. (i.e. Breite des Knotens, Koordinaten, Position im Ranking usw.)}

\paragraph{HierachyLayout.java}\ \\
{\footnotesize Diese Klasse ist zur Berechnung der Hierarchie im Layout zuständig. Jedoch muss berücksichtigt werden, dass eine konsistente Hierarchie nur erreicht werden kann, wenn der Graph, zu dem die Hierarchie berechnet werden soll, ein gerichteter nicht-zyklischer Graph ist. Es muss beachtet werden, dass dieser transitiv reduziert ist. Erneut spielt die Berechnung des Rankings und der virtuellen Knoten eine entscheidende Rolle, wobei diese Berechnungen mit JGraphT stattfinden. Dazu gehört die Beschreibung des zum Knoten gehörenden Vertex (Weite, Rank..). Um das Layout der Hierarchie zu berechnen, wird die eben beschrieben Klasse \texttt{GraphDrawInfo.java} verwendet. Bei der Berechnung werden dabei die 4 Prinzipien berücksichtigt, die in der Dokumentation zur Zeichnung (\texttt{./doc/1993drawing.pdf}) näher erläutert und bei den 3 Durchläufen des "`Network Simplex Algorithm"' beachtet werden. Der konkrete Ablauf, welche Schritte getan werden müssen, werden dort näher erläutert. (Machbarkeitsbaumberechnung mit entsprechendem Ranking der den \G{length-constraints} genügen muss).  Es werden verschiedene Algorithmen ausgeführt, welche mit einigen Hilfsmethoden u.a. Spannbäume mit festen Kanten, machbare Rankings berechnet [...]. Hierbei muss flüchtig erwähnt werden, dass die Berechnung in den Grundzügen auf Ersetzung von Graphkanten und -knoten durch Nichtgraphkanten und -knoten, um die Machbarkeit mit einem optimalem Ranking zu erreichen, basiert. Es wird versucht ein minimalen Graphen zu finden (optimales Ranking), der den 4 Prinzipien genügt. Dabei werden die Variablen der Klasse \texttt{GraphDrawInfo.java} benötigt.} 

\paragraph{LLWalker.java}\ \\
\emph{Erweiterung von TreeDFSWalker.java}\\
{\footnotesize Traversiert die Knoten eines Baumes mithilfe von Tiefensuche, indem die Methoden der Oberklasse verwendet werden.}

\paragraph{Ranks.java}\ \\
{\footnotesize In dieser Klasse werden die Knoten eines Graphen über Rankings verwaltet. Einer der Hauptaspekte für die Verwendung von Rankings ist, dass die Kantenkreuzungen soweit wie möglich minimiert werden. Ein initiales Ranking wird durch Zuweisung eines Rankings für jeden Knoten über Breitensuche (durch Traversierung), wobei bei dem niedrigsten Ranking begonnen wird (in der Anwendung von oben nach unten), erstellt. Das ist notwendig, um sicherzugehen, dass dieses Ranking ein Baum ohne Kantenkreuzungen(möglichst) ist. Um dies zu erreichen wird \texttt{HierarchyLayout.java} verwendet, indem über sie virtuelle Knoten erstellt und gesetzt werden, um ein optimales Ranking für die Kantenkreuzungen zu erreichen. Um die Knoten innerhalb eines Rankings effektiv zu sortieren werden Heuristiken (siehe \texttt{./doc/1993drawing.pdf}) verwendet (z.B. Median, Barycenter, Minimum, Sifting..). Es werden iterative heuristische Berechnungen entsprechend der bereits genannten Dokumentation ausgeführt, um ein bestmögliches in einem akzeptablen Rahmen des Berechnung-Aufwandes Ergebnis zu erzielen (Vertauschung von Knoten, falls dadurch Kreuzungen vermieden werden).}

\paragraph{TightTreeWalker.java}\ \\
\textit{Erweiterung von UBFSWalker.java;\\ wird in} {\small \texttt{HierarchyLayout.java}} \textit{für den "`Network Simplex Algorithm"'\ verwendet}\\
{\footnotesize Diese Klasse wird benötigt um einen gerichteten Graphen mithilfe von Breitensuche \textit{ungerichtet} zu traversieren, dabei werden nur Kanten, die fest("`tight"'$\overset{\wedge}{=}$ slack = 0) sind, berücksichtigt. \\
Es wird ein Startknoten definiert, mit dem diese Traversierung ausgeführt wird. Die zu traversierenden Kanten sind als Baumkanten markiert (Information aus \texttt{GraphDrawInfo.java}). Als Ergebnis erhält man einen Spannbaum für den Ausgabe-Graphen.}

\paragraph{TreeReranker.java}\ \\
\emph{Erweiterung von TreeBFSWalker}\\
{\footnotesize Mithilfe dieser Klasse werden neue Rankings auf einem Layout-Graphen (als Baum übergeben) erstellt, um ein optimales Ranking zu erhalten (durch Breitensuche). Sie wird eigentlich nur verwendet, um eine semantische Trennung zum \texttt{TreeBFSWalker.java} zu erhalten, denn jede verwendete Methode ruft eine entsprechende Methode aus der Oberklasse auf.}

\subsection{ISGCI-Package db}
Hier liegen viele Algorithmen; z.B. beinhaltet die Klasse Algo.java Algorithmen, um Subklassen/Superklassen eines Knoten zu finden und diese auszugeben. Diese werden benötigt, um die Inklusionsinformationen zu speichern und abzurufen.\\

\subsection{ISGCI-Package gc}
\G{GC} steht für GraphClass. In diesem Package sind alle \G{GraphClass} Klassen enthalten. Jede enthaltene Java Klasse beschreibt eine GraphClass und deren besondere Eigenschaften.\\

\subsection{ISGCI-Package iq}
Hier finden ISGCI Queries statt. \G{db} und \G{gc} nutzen dieses Package, um Queries auszuführen. \\

\subsection{ISGCI-Package problem}
\G{Store complexity information for graph problems}, in diesem Package sind alle Funktionen enthalten, die dazu genutzt werden, ein Problem zu beschreiben.\\

\subsection{ISGCI-Package util}
In dem \G{util} Package liegen alle für spezielle Funktionalitäten benötigte Klassen. Dazu gehört eine Reihe von Klassen, die die Verwendung von "`LaTeX"' innerhalb des ISGCI ermöglicht (d.h. das Verwenden einiger LaTeX-Symbole).\\

\subsection{ISGCI-Package xml}
Das Package \G{xml} ist zum Input/Output von XML Dateien; hier werden Informationen aus XML Dateien gelesen und ausgegeben. Das Package \G{xml} greift dabei auf das Package \G{sax} zu und nutzt deren Filterfunktionalität. Die Daten aus einem XML input/output werden den Klassen \G{Grapht}, \G{ISG} und \G{Util} zur Verfügung gestellt. \\

\subsection{ISGCI-Package isq}
In \G{isg} werden die Graph Familien, Zusammenhänge aus einer XML gelesen und zum Zeichnen vorbereitet, also an JGraphT weitergereicht. Dabei nutzt \G{isg} Funktionen des \G{util} Packages. 

\subsection{ISGCI-Package sax}
Das Package \G{sax} beinhaltet nur die Klasse XMLWriter.java. Diese ist ein Filter, um ein XML Dokument aus einem SAX (Simple API for XML) event stream zu erzeugen. Diese Klasse wird vom XML Parser benötigt.

\subsection{ISGCI-Package gui}

\paragraph{AboutDialog}\ \\Zeigt den \G{About}$-$Dialog an, der erscheint, wenn man unter \G{Help} auf \G{About} klickt.

\paragraph{CheckInclusionDialog}\ \\Zeigt den Dialog an, bei dem man zwei Klassen selektieren kann und prüfen kann, ob eine Relation besteht. Dabei kann nach Namen gefiltert werden.

\paragraph{EdgePopup}\ \\Erstellt das Popup Menu, auf das man zugreifen kann, wenn man Rechtsklick auf eine Edge(View) macht. Dabei wird Information angezeigt.

\paragraph{EdgeView}\ \\Erzeugt einen View von einer Edge. Zeichnet die Edge und sorgt dafür, dass Pfeilspitzen angezeigt werden.

\paragraph{ExportDialog}\ \\Eine Klasse, die einen Export Dialog erzeugt, in dem der Nutzer \G{Fileformat}, \G{postscrip options} und \G{GraphML} Optionen auswählen kann. Es kann die Zieldatei ausgewählt werden. Bei Bestätigung wird die Datei mit den Einstellungen erzeugt. Andernfalls wird ein Error erzeugt.

\paragraph{GraphCanvas}\ \\Das Display auf dem der Graph gezeichnet wird. Dabei kann der Canvas gelöscht werden und dem Canvas kann ein übergebener Graph hinzugefügt werden.

\paragraph{GraphClassInformationDialog}\ \\Zeigt den Dialog \G{Graph Class Information} an. Dabei werden von der selektierten \G{GraphClass} die Probleme, deren Komplexität, Superklassen, Äquivalentklassen und Subklassen angezeigt.

\paragraph{GraphClassSelectionDialog}\ \\Zeigt den Dialog \G{Graph Classes Selection} an, der erscheint, wenn man bei \G{Graph Class Information} auf \G{Draw} klickt. Bei Doppelklick wird der Canvas mit der Klasse, die markiert wurde, neu gezeichnet. Kann eine Collection der Classes zurückgeben, die der Benutzer selektiert. 

\paragraph{GraphView}\ \\Zeigt den Graphen auf dem Canvas an. Es wird eine neue \G{GraphView} mit den Knoten(Nodes) aus \G{DataSet.inclGraph} gezeichnet. Dabei werden die Nodes und der GraphCanvas, der den Graphen anzeigt, übergeben. Kann überprüfen, ob ein Knoten virtuell ist oder nicht. Im \G{layout} werden \G{EdgeView}s erstellt und an die richtige Position bewegt. Dabei werden jeweils immer die Bounds neu berechnet.

\paragraph{InclusionResultDialog}\ \\Zeigt nach Klick auf \G{Find Relation} an, ob eine Relation zwischen zwei Graph Klassen besteht. Wenn nein, werden die minimal ähnlichen Superklassen und die maximal ähnlichen Subklassen angezeigt. Gibt auch an, warum keine Relation existiert.

\paragraph{IQDialog}\ \\In dieser Klasse sind die Dialogfenster für die drei Menüpunkte im Menü \G{Graphclasses}, mit denen man auswählen kann, welche Graphen man sich zeichnen lassen möchte.

\paragraph{ISGCIGraphCanvas}\ \\Klasse für den Canvas ("`Leinwand"', sprich der weiße Bereich in der Mitte) auf der der Graph gezeichnet wird. Bekommt einen Graphen der Klasse \\\G{SimpleDirectedGraph<Set<GraphClass>,DefaultEdge>} übergeben und zeichnet diesen. Einfärbung ist ebenfalls in dieser Klasse implementiert.

\paragraph{ISGCIMainFrame}\ \\Der \G{Main Frame} der Anwendung. Besteht aus der \G{JMenuBar}, bekommt den Canvas übergeben und fügt Scrollbars, sämtliche Buttons und Event Listeners hinzu.

\paragraph{LatexGraphics}\ \\Diese Klasse ist zuständig für die Zeichnung von Latex Strings, die in der Bezeichnung einiger Graphen in der Datenbank enthalten ist.

\paragraph{LatexLabel}\ \\In dieser Klasse werden zusammen mit den LatexGraphics die gesamten Labels gezeichnet, die in einen Graphen hinein kommen.

\paragraph{ListGroup}\ \\Kommentar:"`A group of lists in which only one item can be selected."'\\ 
Wird für einen gezeichneten Graphen benutzt, damit man nur einen Knoten anwählen kann und es somit keine Probleme für die Event Handler gibt.

\paragraph{MessageDialog}\ \\Einfache Klasse für Ja/Nein Dialogfenster, die öfter vorkommen.

\paragraph{NamingDialog}\ \\Der \G{Naming} Dialog im Menü unter \G{View $\rightarrow$ Naming preference}. Damit kann man einstellen, nach welchen Kriterien die Knoten benannt werden sollen.

\paragraph{NodeList}\ \\\G{JList} für Knoten mit Standard Listenmethoden, die in HTML ausgegeben werden können.

\paragraph{NodePopup}\ \\Klasse des Popup Menüs, das bei Rechtsklick auf einen angewählten Knoten erscheint. Hat Buttons für die Funktionen "`Change Name"' und "`Information"'

\paragraph{NodeView}\ \\Klasse der gezeichneten Knoten-Objekte inklusive Label, die sich bewegen lassen.

\paragraph{NulGraphics}\ \\Eine Klasse, die zur Evaluierung der Größe dargestellter Strings dient. Die Klasse erbt von Graphics, implementiert jedoch nur die Methoden, welche zur Schriftverwaltung dienen.

\paragraph{OpenProblemDialog}\ \\Eine Klasse, die einen Benutzer Dialog erzeugt, in welchem eine Auswahl der Graph-Klassen, bezüglich des gewählten Problems, zur Verfügung gestellt wird. Die Graph-Klassen sind unterteilt in drei \G{JLists} für "`Minimal (co)NP-vollständig"', "`offen"' oder "`Maximal P"'.  Der Benutzer kann innerhalb dieser Listen Graphklassen auswählen und über Buttons entweder die gewählten Klassen zeichnen oder weitere Informationen erhalten. Dazu wird mithilfe des \G{ActionListeners} entweder ein \G{GraphClassInformationDialog} zur gewählten Graph-Klasse geöffnet oder mithilfe des \G{GraphCanvas} die Auswahl gezeichnet.

\paragraph{ProblemsMenu}\ \\Stellt das unter \G{Problem $>$ Colour for Problem} dargestellte Menu mit RadioButtons für jedes Graphproblem zur Verfügung. Die Liste der Probleme wird über teo.isgci.db.DataSet zur Verfügung gestellt.

\paragraph{PSFontMetrics}\ \\Diese Klasse dient zum Verwalten der genutzten Schriftarten Helvetica und ISGCIFont.

\paragraph{PSGraphics}\ \\Eine Klasse, welche die grafische Verarbeitung für Postscript verwaltet. Methoden, welche nicht für die Nutzung in ISGCI relevant sind, erzeugen eine \G{RuntimeException}. Es sind Methoden zum Zeichnen von Elementen (Nodes, Arrows) und zum Schreiben von Strings enthalten. Außerdem Verwaltungsmethoden zur Steuerung der Postscript Befehle. 

\paragraph{ScaleMenu}\ \\Auskommentierte Klasse ohne relevanten Inhalt. Sollte voraussichtlich zur Skalierung der Zeichnung verwendet werden.

\paragraph{SColor}\ \\Eine Klasse, welche mithilfe der Methode \G{brighter(Color c)} eine, um einen festen Faktor hellere, Version der Farbe \G{c} erzeugt und zurückgibt. Außerdem ist eine Methode enthalten, welche überprüft, ob eine Farbe eine Graustufe ist und eine weitere, um diese Graustufe zu erhalten.

\paragraph{SearchDialog}\ \\Stellt den Dialog "`Search for a graphclass"' unter \G{View $>$ Search} in \G{Drawing} zur Verfügung. Innerhalb des Konstruktors wird durch Abfrage des \G{GraphCanvas} eine Liste aller gezeichneten Knoten erzeugt und als JList im Dialog dargestellt. Der Nutzer kann innerhalb dieser Liste eine Graph-Klasse auswählen und mithilfe des \G{Search} Buttons innerhalb der Zeichnung nach dieser Suchen. Dazu werden im \G{GraphCanvas} die Methoden \G{findNode(...)}, \G{markOnly(...)} und \G{centerNode(...)} genutzt, welche die gewählte Graph-Klasse markieren und im Canvas zentriert darstellen. 

\paragraph{SmartGraphics}\ \\Eine abstrakte Klasse, welche von Graphics erbt und Methoden zum Zeichnen von Graphen enthält. (Zeichnen von Nodes: \G{drawNode(...)} und Zeichnen von Pfeilen:\G{ drawArrow(...)})

\paragraph{SVGGraphics}\ \\Klasse, die von SmartGraphics erbt und zum Erzeugen von SVG Grafiken zuständig ist. Hierzu implementieren die, von SmartGraphics geerbten Methoden, Funktionen zur Erzeugung einer SVG Datei.

\paragraph{View}\ \\Ein Interface, welches Methoden zur Implementierung von Objekten, welche auf einem \G{GraphCanvas} gezeichnet werden können, zur Verfügung stellt.

\paragraph{VirtualNodeView}\ \\Klasse, welche von NodeView erbt und zum Erzeugen eines leeren Knotens dient. So kann innerhalb einer Ebene ein leerer Knoten erzeugt werden, um die hierarchische Darstellung beizubehalten.

\paragraph{WebSearch}\ \\Eine Klasse, welche von \G{JTextField} erbt und ein Textfeld zur Suche innerhalb der \G{ISGCI Online Datenbank} dient. Hierzu wird eine Verbindung zur Webseite hergestellt und die Suche über den Browser realisiert, indem der eingegebene Suchbegriff als Parameter in die URL hinzugefügt wird. Die dabei entstehenden Suchergebnisse werden zeilenweise eingelesen und der Ergebnisliste hinzugefügt. Anschließend wird aus \G{DataSet} die entstandene Liste als Liste von auswählbaren Elementen umgewandelt und in der Liste der Graph-Klassen angezeigt. 

%%ab hier wirds ernst
\section{Vorgeschlagene Software Architektur}
\subsection{Übersicht}
Um neue Funktionalitäten von JGraphX hinzufügen zu können, werden grundlegende Änderungen am ISGCI vorgenommen. Dies umfasst das Einführen einer neuen Struktur, in der die Graphinformationen (Knoten (Graphklassen) und Kanten (Inklusionen)) gespeichert werden, Veränderungen des Canvas, auf dem der Graph gezeichnet wird und Veränderungen am GUI, um die neuen Funktionen für den User sichtbar zu machen.
\subsection{ISGCIGraph.java}
Wir erstellen eine neue Klasse ISGCIGraph im neuen Package .teo.isgci.jgraphx, welche die Klasse mxGraph(JGraphX) erweitert und als Schnittstelle zwischen ISGCI und JgraphX fungiert.\\
Die Erweiterung der Klasse \G{mxGraph} ermöglicht uns die Benutzung der Layout-Funktionen der JGraphX-Bibliothek. Für das Layout wird die Klasse "`mxHierarchicalLayout.java"' verwendet, die das Aussehen des Graphen(über Ranking) verbessert. 
 Durch die Zusammenführung des \G{DirectedGraph}(JGraphT) und \G{mxGraph}(JGraphX) sorgen wir dafür, dass keine doppelte Datenhaltung vorliegt, denn alle Knoten und Kanten werden in JGraphX-Cells abgelegt. Sie sind weiterhin wie in einem \G{DirectedGraph} erreichbar. Bei der Implementierung ist besonders darauf zu achten, dass der Zugriff auf Kanten und Knoten des Graphen effizient umgesetzt wird, damit \G{Userexperience} und \G{Usability} nicht unter langen Wartezeiten leidet.\\\\
Durch die Implementierung des \G{DirectedGraph}-Interfaces und setzen der Instanzvariablen "`protected boolean multigraph = false"' und "`allowLoops = false;"' des \G{mxGraph}s können wir den neuen \G{ISGCIGraph} wie den "`SimpleDirectedGraph"' der bisherigen Implementation verwenden, da sie die selben Eigenschaften (gerichtet, keine Kreise und keine Multikanten) haben. Diese Funktionen beinhalten unter anderem: 
{\small
\begin{itemize}
\item Erstellen des Graphen aus der heruntergeladenen \G{ISGCI.xml}
\item Mittels Walkern, aus dem \G{.teo.jgrapht}-Package, den Graphen traversieren
\item Suche nach Problemklassen mittels des \G{.teo.problem}-Packages
\item Export des Graphen
\item Zeichnen des Graphen\\
\end{itemize}
}
\ \\
Dazu müssen folgende Klassen angepasst werden, die einen \G{SimpleDirectedGraph} verwenden:
{\small 
\begin{description}
\item FindISG.java
\item Algo.java
\item DataSet.java
\item ForbiddenClass.java
\item BFSWalker.java
\item Deducer.java
\item DFSWalker.java
\item GAlg.java
\item GraphCanvas.java (hier finden noch weitere, grundlegende Änderungen statt, s.u.)
\item GraphView.java (hier finden noch weitere, grundl. Änderungen statt, s.u.)
\item ISGCIGraphCanvas.java (hier finden noch weitere, grundl. Änderungen statt, s.u.)
\item ISGCIMainFrame.java (hier finden noch weitere, grundl. Änderungen statt, s.u.)
\item LandMarks.java
\item ISGCIWriter.java
\end{description}}\ \\
 Durch das Erweitern des \G{mxGraph} erhalten wir folgende Funktionalität: 
 \begin{itemize}
 \item Automatisches Layout mittels \G{mxGraph.layout.mxHierarchyLayout;} \\dies ersetzt das \G{teo.layout}$-$Package der bisherigen Implementation.
 \item Zeichnen des Graphen mittels JGraphX-Funktionen auf eine \G{mxICanvas}
 \item Effizienter Zugriff auf alle Elemente des Graphen
 \item Verschieben von Knoten
 \end{itemize}
\subsection{ISGCI.Gui}
\paragraph{Grundlegende Änderungen}\ \\
Die bereits existierende Klasse \G{ISGCIGraphCanvas.java} aus dem ISGCI Projekt wird so verändert, dass sie die Funktionalität der \G{mxGraphics2Dcanvas.java} realisiert. Die Klasse \G{NodeView.java} wird durch eine Klasse \G{NodeCell.java} ersetzt, diese erweitert die Klasse \G{mxCell.java}. Die Klasse \G{NodeCell} enthält Methoden, welche die NodeView Funktionalitäten dahingehend umsetzen, dass sie die Parameter in das für die \G{NodeCell} entsprechende Format überführen. Weiterhin wird eine Klasse \G{EdgeCell.java} die bisherige Klasse \G{EdgeView.java} ersetzen. Hier werden jedoch nun \G{Inclusions} gespeichert. 
%hier Bildchen einfügen
JGraphX übernimmt mit dem ISGCIGraph, den angehängten \G{mxCells}, \G{mxCellStates} und der \G{ISGCIGraphCanvas} selbstständig das Zeichnen des Graphen.

%\paragraph{Layoutverbesserungen}
\paragraph{Detail-Sidebar} \ \\
Es wird eine Klasse \G{Sidebar.java} im Package \G{teo.isgci.gui} implementiert, welche Details zu einem ausgewählten Knoten enthält. Diese Klasse erweitert die Klasse \G{JPanel}. Die anzuzeigenden Informationen werden mithilfe der Klasse \G{DataSet} ausgelesen. Bei Programmstart ist die \G{Sidebar} ausgeblendet. Es werden folgende Optionen zum Anzeigen der Sidebar implementiert:
\begin{itemize}
\item Menu-Bar-Parent \G{View}; \G{Details visible}, welche in der \G{ISGCIMainFrame} Klasse implementiert wird. 
\item Kontext-Menü; \G{Show Details}, vgl. Kontextmenü. 
\item Menu-Bar-Parent \G{Selected}, \G{Show Details}, welche in der \G{ISGCIMainFrame} Klasse implementiert wird. 
\end{itemize} 
Es existiert ein Button, um die Sidebar auszublenden. Das ist zudem auch über das Menu-Bar-Parent \G{View}, \G{Details visible} möglich.\\


\paragraph{Knoten Verschieben}\ \\ 

Wird wie bisher in der ISGCIGraphCanvas.java Klasse realisiert.

\paragraph{Zoom (Mausrad)}\ \\ 

Wird über Veränderung der "`Scale"'-Variable im ISGCIGraph assoziierten GraphView und auswerten eines MouseWheelListeners ausgelöst.

\paragraph{Zoom (Menu-Bar)}\ \\ 

In der ISGCIMainFrame.java Klasse werden die Menüs und dazugehörigen Items erzeugt. Hier werden wir die Methoden, createMenus() und registerListeners() anpassen. Anschließend wird die interaktive Funktionalität der neu hinzugefügten Komponenten durch eine Anpassung der actionPerformed() gewährleistet. Hier wird auch die "`Scale"'-Variable im ISGCIGraph assoziierten GraphView verändert.

\paragraph{Tooltip}\ \\ 

Wird in der ISGCIGraphCanvas.java realisiert. Es wird über den MouseListener implementiert, der falls er über dem Knoten verweilt den Tooltip, dessen Form in der neuen Klasse ISGCINodeTooltip beschrieben wird.

\paragraph{Tooltip Inhalt}\ \\ 

 Der ISGCINodeTooltip greift auf Daten in der Klasse DataSet.java aus dem Package teo.isgci.db zu. Er enthält alle alternativen Namen des Nodes (der aktuelle Name inbegriffen) in Listenform.

\paragraph{Scrolling}\ \\ 
In der ISGCIMainFrame.java Klasse existiert bereits eine Methode createCanvasPanel(), welche den Canvas und die Scrollbalken unten und rechts des Canvas erzeugt. Um sich darin auch per click and pull bewegen zu können erstellen wir eine weitere Methode in dieser Klasse, die das MousePressed Event auswertet, wenn es nicht auf einem Knoten liegt und den Viewport anpasst.

\paragraph{Kontextmenü}\ \\ 
NodePopup.java ist eine bereits existierende Klasse die das Kontextmenü bereitstellt, das bei einem Rechtsklick, auf einen Knoten, aufgerufen wird. Dieses wird von uns um die folgenden Punkte erweitert. 
%(Dieser Punkt wird in der 2. Version des SDD ausgeführt)

\paragraph{Kontextmenü Superklassen}\ \\ 
In NodePopup.java werden zwei neue Items durch anpassen des Konstruktors der NodePopup-Klasse implementiert und die dazugehörige Funktionalität durch anpassen der actionPerformed() Methode aufgerufen. actionPerformed() ruft dabei Informationen über den angewählten Knoten und dessen Superklassen ab und zeichnet das Ergebnis (die Knoten) auf den Canvas, hierfür erstellen wir eine Methode "`private Object[] getSupernodes(Object cell)"'. Dafür rufen wir "`mxGraph.getAllEdges(Object cell)"' mit selbigem Knoten auf, suchen aus dem Ergebnis alle Vorgängerknoten heraus (rekursiv für Kanten, die eine Kante als Vorgänger haben) und wenden auf diese "`mxGraph.toggleCells( boolean show, Object[] cells)"' an.

\paragraph{Kontextmenü Subklassen}\ \\ 
In NodePopup.java werden zwei neue Items durch anpassen des Konstruktors der NodePopup-Klasse implementiert und die dazugehörige Funktionalität durch anpassen der actionPerformed() Methode aufgerufen. actionPerformed() ruft dabei Informationen über den angewählten Knoten und dessen Subklassen ab und zeichnet das Ergebnis (die Knoten) auf den Canvas, hierfür erstellen wir eine Methode "`private Object[] getSubnodes(Object cell)"'. Dafür rufen wir "`mxGraph.getAllEdges(Object cell)"' mit selbigem Knoten auf, suchen aus dem Ergebnis alle Nachfolgerknoten heraus (rekursiv für Kanten, die eine Kante als Nachfolgerknoten haben) und wenden auf diese "`mxGraph.toggleCells( boolean show, Object[] cells)"' an.

\paragraph{Kontextmenü Nachbarn}\ \\ 
In NodePopup.java werden zwei neue Items durch anpassen des Konstruktors der NodePopup-Klasse implementiert und die dazugehörige Funktionalität durch anpassen der actionPerformed() Methode aufgerufen. actionPerformed() ruft dabei Informationen über den angewählten Knoten und dessen Nachbarn ab und zeichnet das Ergebnis (die Knoten) auf den Canvas, hierfür erstellen wir eine Methode "`private Object[] getNeighbour(Object cell)"'. Dafür rufen wir "`mxGraph.getAllEdges(Object cell)"' mit selbigem Knoten auf, und wenden auf diese "`mxGraph.toggleCells( boolean show, Object[] cells)"' an.


\newpage
\section{Hardware/Software Mapping}
\subsection{Architektur}
ISGCI benötigt als Hard-/Software Umgebung eine lauffähige Java-Laufzeit-Umgebung. Für weitere Informationen zu den Hard-/Software-Anforderungen besuchen Sie bitte 
\href{http://www.oracle.com/technetwork/java/javase/system-configurations-135212.html}{Java 6 - Anforderungen} (06.06.2013).
\\Zusätzlich wird für die Filterfunktion eine ständige Internetverbindung vorausgesetzt.

\subsection{Management der persistenten Daten}
Alle zu speichernde Daten werden in der Datenbank online gespeichert ,werden beim Start der Anwendung heruntergeladen und liegen im XML-Format vor.
\subsection{Randbedingungen}
\paragraph{Starten der Anwendung}
Wenn keine Internetverbindung: Fenster "'Anwendungsfehler: Anwendung kann nicht gestartet werden."' dies tritt nicht immer auf; das Verhalten ist nicht spezifiziert.
\paragraph{Beenden der Anwendung}
Es wird kein Zustand gespeichert, die Anwendung beendet sich sofort.
\section{Testing}
Es wird ein \G{Grey Box testing} Ansatz verwendet, d.h. der Testende hat gegebenenfalls Zugriff auf den Sourcecode, kennt allerdings nicht unbedingt die vollständige Implementierung der Funktion. Dabei wird gegen die Beschreibung des bereits bestehenden Systems (siehe: \autoref{sec:bestSys}) getestet.\\
Wir gliedern das Testing in folgende Testphasen:
{\small\begin{itemize}
\item Unit Testing
\item Integration Testing (Modul Testing)
\item Software Testing
\item Functionality Testing
\item Acceptance Testing\\
\end{itemize}}
Diese sind folgendermaßen aufgebaut:
\subparagraph{Unit Testing}\ \\
Für jede angepasste bzw. selbst geschriebene Klasse wird bereits während deren Implementation ein JUnit Testfile entworfen. Dieses beinhaltet Tests zu jeder Methode, welche mit fiktiven Parametern aufgerufen werden, um deren korrekte Ausführung zu testen. Die Testfiles werden jeweils nicht von den Programmierern der Methoden bzw. Klassen geschrieben, sondern von einem anderen Teammitglied. Das Feedback hat Änderungen am Programmcode zur Folge, falls Abweichungen auftreten.

\subparagraph{Integration Testing}\ \\
Sind alle JUnit Tests erfolgreich durchgeführt worden, werden die einzelne Module (Packages) auf ihre Funktionalität, alleine und in Kombination, getestet. Hierbei wird das angehängte Testprotokoll (siehe: \autoref{sec:testp}) verwendet. Beim Test eines Moduls werden benötigte Parameter, die über Schnittstellen zur Verfügung gestellt werden sollten, durch sinnvolle fiktive Eingabewerte ersetzt. Ist ein Modul auf diese Weise erfolgreich getestet worden, so werden inkrementell benötigte andere Module, sofern diese auch erfolgreich getestet wurden, hinzugefügt. Die zusammengesetzten Module werden nach dem selben Prinzip auf ihre Funktionalität überprüft, bis dabei das gesamte System zusammengefügt wurde. Das Feedback hat Änderungen am Programmcode zur Folge, falls Abweichungen auftreten.

\subparagraph{Software Testing}\ \\
Hierbei wird der zur Verfügung stehende Prototyp auf die Umsetzung der funktionalen Anforderungen überprüft. Dazu werden spezifische Testszenarien (Template siehe: \autoref{sec:tests}) festgelegt, die Benutzerinteraktion darstellen. Die Testszenarien werden jeweils von einem Teammitglied durchgeführt und das Ergebnis wird im Template protokolliert. Das Feedback hat Änderungen am Softwaredesign zur Folge, falls Abweichungen auftreten.

\subparagraph{Functionality Testing}\ \\
Für die Beta Version und den Release Candidate wird ein Functionality Testing durchgeführt. Dabei wird das System auf einem Endbenutzergerät ausgeführt, auf dem bisher keinerlei Entwicklung stattgefunden hat, wobei ein reales Nutzungsszenario simuliert wird, der Tester versucht das System zum Zusammenbrechen zu bringen. Dieses wird von der durchführenden Person protokolliert, insbesondere Fehler und der Weg zu ihnen. Es wird das gleiche Template (\autoref{sec:tests}) wie für Szenarien verwendet. Das Feedback hat Änderungen am Softwaredesign zur Folge, falls Abweichungen auftreten.

\subparagraph{Acceptance Testing}\ \\
Nachdem der Release Candidate fertig gestellt wurde, wird dieser dem Kunden zum Acceptance Testing zur Verfügung gestellt. Das Feedback des Kunden hat Änderungen an der Spezifikation zur Folge, insofern sie im Zeitplan umsetzbar sind. Sind die Änderungen umfangreicher wird der Releasetermin und das Budget neu verhandelt.

\section{Anhang} \ \\

Anbei das Protokoll Layout zur Nutzung während der Modultests und ein Beispielszenario zur Nutzung während dem Software Testing.
\newpage
\subsection{Testprotokoll}
\label{sec:testp}
\input{Testprotokoll}
\newpage
\subsection{Testszenario}
\label{sec:tests}
\input{Testszenario}


\end{document}
